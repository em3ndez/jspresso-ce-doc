Reference for Module hierarchy
==============================

Module
------

-   **Full name** : ``

-   **Super-type** : `AbstractPropertyChangeCapable`

-   **Sub-types** : ``, ``

A module is an entry point in the application. Modules are organized in bi-directional, parent-children hierarchy. As such, they can be viewed (and they are materialized in the UI) as trees. Modules can be (re)organized dynamically by changing their parent-children relationship and their owning workspace UI will reflect the change seamlessly, as with any Jspresso model (in fact workspaces and modules are regular beans that are used as model in standard Jspresso views). Modules, among other features, are capable of providing a view to be installed in the UI wen they are selected. This makes Jspresso applications really modular and their architecture flexible enough to embed and run a large variety of different module types. A module can also be as simple as a grouping structure for other modules (intermediary nodes).

<table>
<caption>Module properties</caption>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p><strong>description</strong></p>
<p><code>String</code></p></td>
<td align="left"><p>Configures the key used to translate actual internationalized module description. The resulting translation will generally be leveraged as a toolTip on the UI side but its use may be extended for online help.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>entryAction</strong></p>
<p><code></code></p></td>
<td align="left"><p>Configures an action to be executed every time the module becomes the current selected module (either through a user explicit navigation or a programmatic selection). The action will execute in the context of the current workspace, this module being the current selected module.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>exitAction</strong></p>
<p><code></code></p></td>
<td align="left"><p>Configures an action to be executed every time the module becomes unselected (either through a user explicit navigation or a programmatic deselection). The action will execute in the context of the current workspace, this module being the current selected module (i.e. the action occurs before the module is actually left).</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>grantedRoles</strong></p>
<p><code>Collection​&lt;​String​&gt;​</code></p></td>
<td align="left"><p>Assigns the roles that are authorized to start this module. It supports &quot;<strong>!</strong>&quot; prefix to negate the role(s). Whenever the user is not granted sufficient privileges, the module is simply not installed in the workspace. Setting the collection of granted roles to {@code null} (default value) disables role based authorization on this module. Some specific modules that are component/entity model based i.e. {@code Bean(Collection)Module} also inherit their authorizations from their model.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>icon</strong></p>
<p><code></code></p></td>
<td align="left"><p>Sets the icon.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>iconImageURL</strong></p>
<p><code>String</code></p></td>
<td align="left"><p>Sets the icon image URL of this descriptor. Supported URL protocols include :</p>
<ul>
<li><p>all JVM supported protocols</p></li>
<li><p>the <strong>jar:/</strong> pseudo URL protocol</p></li>
<li><p>the <strong>classpath:/</strong> pseudo URL protocol</p></li>
</ul></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>iconPreferredHeight</strong></p>
<p><code>int</code></p></td>
<td align="left"><p>Sets the icon preferred width.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>iconPreferredWidth</strong></p>
<p><code>int</code></p></td>
<td align="left"><p>Sets the icon preferred width.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>name</strong></p>
<p><code>String</code></p></td>
<td align="left"><p>Configures the key used to translate actual internationalized module name. The resulting translation will be leveraged as the module label on the UI side.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>permId</strong></p>
<p><code>String</code></p></td>
<td align="left"><p>Sets the permanent identifier to this application element. Permanent identifiers are used by different framework parts, like dynamic security or record/replay controllers to uniquely identify an application element. Permanent identifiers are generated by the SJS build based on the element id but must be explicitly set if Spring XML is used.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>projectedViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Configures the view descriptor used to construct the view that will be displayed when this module is selected.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>startupAction</strong></p>
<p><code></code></p></td>
<td align="left"><p>Configures an action to be executed the first time the module is &quot;started&quot; by the user. The action will execute in the context of the current workspace, this module being the current selected module. It will help initializing module values, notify user, ....</p></td>
</tr>
</tbody>
</table>

BeanCollectionModule
--------------------

-   **Full name** : ``

-   **Super-type** : ``

-   **Sub-types** : ``, ``

This type of module keeps a reference on a beans collection. There is no assumption made on whether these beans are actually persistent entities or any other type of java beans.

Simple bean collection modules must have their collection of referenced beans initialized somehow. There is no standard built-in action to do so, since it is highly dependent on what's needed. So it's rather common to have the module content initialized through a startup action depending on the session state.

<table>
<caption>BeanCollectionModule properties</caption>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p><strong>elementComponentDescriptor</strong></p>
<p><code>​&lt;​Object​&gt;​</code></p></td>
<td align="left"><p>Configures the type of bean element this collection module manages. A bunch of default values are inferred from this element component descriptor. For instance, paging size (if used) will default to the component one unless explicitly set. Same goes for icon image URL, default ordering properties or even granted roles. The latter means that bean collection modules based on forbidden entities will automatically be excluded from the workspace of the logged-in user.</p>
<p>if not explicitly configured, the element component descriptor can be inferred from the collection view descriptor configured as projected view descriptor.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>elementViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>This property is not used by the module itself, but by built-in actions that maybe registered on this module. One of these actions is {@code AddBeanAsSubModuleAction}.</p>
<p>This property indicates the view to use whenever the user requests a &quot;form-like&quot; view on a collection element. Naturally the configured element view descriptor must be backed by a model matching the type of the module managed beans.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>moduleObjects</strong></p>
<p><code>List​&lt;​?​&gt;​</code></p></td>
<td align="left"><p>Assigns the list of beans this module manages. The projected view will automatically reflect this change since a &quot;moduleObjects&quot; property change will be fired.</p></td>
</tr>
</tbody>
</table>

FilterableBeanCollectionModule
------------------------------

-   **Full name** : ``

-   **Super-type** : ``

-   **Sub-types** : ``

This is a specialized type of bean collection module that provides a filter ( an instance of {@code IQueryComponent} ). This type of module, coupled with a generic, built-in, action map is perfectly suited for CRUD-like operations.

<table>
<caption>FilterableBeanCollectionModule properties</caption>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p><strong>displayPageIndex</strong></p>
<p><code>Integer</code></p></td>
<td align="left"><p>Delegates to filter.</p>
<p>{@inheritDoc}</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>filter</strong></p>
<p><code></code></p></td>
<td align="left"><p>Assigns the filter to this module instance. It is by default assigned by the module startup action (see {@code InitModuleFilterAction}). So if you ever want to change the default implementation of the filter, you have to write and install you own custom startup action or explicitly inject a specific instance.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>filterComponentDescriptor</strong></p>
<p><code>​&lt;​​&gt;​</code></p></td>
<td align="left"><p>This property allows to configure a custom filter model descriptor. If not set, which is the default value, the filter model is built out of the element component descriptor (QBE filter model).</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>filterViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>This property allows to refine the default filer view to re-arrange the filter fields. Custom filter view descriptors assigned here must not be assigned a model descriptor since they will be at runtime. This is because the filter component descriptor must be reworked - to adapt comparable field structures for instance.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>orderingProperties</strong></p>
<p><code>Map​&lt;​String​,​&gt;​</code></p></td>
<td align="left"><p>Configures a custom map of ordering properties for the result set. If not set, which is the default, the elements ordering properties is used.</p>
<p>This property consist of a {@code Map} whose entries are composed with :</p>
<ul>
<li><p>the property name as key</p></li>
<li><p>the sort order for this property as value. This is either a value of the {@code ESort} enum (<em>ASCENDING</em> or <em>DESCENDING</em>) or its equivalent string representation.</p></li>
</ul>
<p>Ordering properties are considered following their order in the map iterator.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>page</strong></p>
<p><code>Integer</code></p></td>
<td align="left"><p>Delegates to filter.</p>
<p>{@inheritDoc}</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>pageSize</strong></p>
<p><code>Integer</code></p></td>
<td align="left"><p>Configures a custom page size for the result set. If not set, which is the default, the elements default page size is used.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>paginationViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Configures the sub view used to navigate between the pages.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>pagingAction</strong></p>
<p><code></code></p></td>
<td align="left"><p>Sets the pagingAction.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>queryComponentDescriptorFactory</strong></p>
<p><code></code></p></td>
<td align="left"><p>Sets the queryComponentDescriptorFactory.</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>queryViewDescriptorFactory</strong></p>
<p><code></code></p></td>
<td align="left"><p>Sets the queryViewDescriptorFactory.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>recordCount</strong></p>
<p><code>Integer</code></p></td>
<td align="left"><p>Delegates to filter.</p>
<p>{@inheritDoc}</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>selectedRecordCount</strong></p>
<p><code>Integer</code></p></td>
<td align="left"><p>Delegates to filter.</p>
<p>{@inheritDoc}</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>stickyResults</strong></p>
<p><code>List​&lt;​?​&gt;​</code></p></td>
<td align="left"><p>Delegates to filter. {@inheritDoc}</p></td>
</tr>
</tbody>
</table>

MobileFilterableBeanCollectionModule
------------------------------------

-   **Full name** : ``

-   **Super-type** : ``

This is a specialized type of filterable bean collection module that provides a filter ( an instance of {@code IQueryComponent} ). This type of module, coupled with a generic, built-in, action map is perfectly suited for CRUD-like operations.

<table>
<caption>MobileFilterableBeanCollectionModule properties</caption>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p><strong>elementViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Mobile filterable bean collection module views only support page views as element views descriptors. {@inheritDoc}</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>filterViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Mobile filterable bean collection module views only support mobile component views as filter views descriptors. {@inheritDoc}</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>paginationViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Not supported in mobile environment. {@inheritDoc}</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>projectedViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Mobile filter bean collection module views only support list views as projected view descriptors. {@inheritDoc}</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>queryModuleFilterAction</strong></p>
<p><code></code></p></td>
<td align="left"><p>Sets query module filter action.</p></td>
</tr>
</tbody>
</table>

MobileBeanCollectionModule
--------------------------

-   **Full name** : ``

-   **Super-type** : ``

This type of module keeps a reference on a beans collection. There is no assumption made on whether these beans are actually persistent entities or any other type of java beans. Simple bean collection modules must have their collection of referenced beans initialized somehow. There is no standard built-in action to do so, since it is highly dependent on what's needed. So it's rather common to have the module content initialized through a startup action depending on the session state.

<table>
<caption>MobileBeanCollectionModule properties</caption>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p><strong>elementViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Mobile bean collection module views only support page views as element views descriptors. {@inheritDoc}</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>projectedViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Mobile bean collection module views only support list views as projected view descriptors. {@inheritDoc}</p></td>
</tr>
</tbody>
</table>

BeanModule
----------

-   **Full name** : ``

-   **Super-type** : ``

-   **Sub-types** : ``

This type of module keeps a reference on a single bean. There is no assumption made on whether this bean is actually a persistent entity or any other type of java bean.

Bean modules must have their referenced bean initialized somehow. So it's rather common to have the module content initialized through a startup action depending on the session state or dynamically constructed by a standard action like {@code AddBeanAsSubModuleAction}.

This type of module is definitely the one that offers maximum flexibility to handle arbitrary models.

<table>
<caption>BeanModule properties</caption>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p><strong>componentDescriptor</strong></p>
<p><code>​&lt;​Object​&gt;​</code></p></td>
<td align="left"><p>Configures the type of bean this module manages. A bunch of default values are inferred from this component descriptor. For instance, icon image URL or even granted roles can be inferred from the configured component descriptor. The latter means that bean modules based on forbidden entities will automatically be excluded from the workspace of the logged-in user.</p>
<p>However, when not set, the component descriptor it self can be inferred from the configured projected view descriptor model.</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>moduleObject</strong></p>
<p><code>Object</code></p></td>
<td align="left"><p>Assigns the bean this module manages. The projected view will automatically reflect this change since a &quot;moduleObject&quot; property change will be fired.</p></td>
</tr>
</tbody>
</table>

MobileBeanModule
----------------

-   **Full name** : ``

-   **Super-type** : ``

This type of module keeps a reference on a single bean. There is no assumption made on whether this bean is actually a persistent entity or any other type of java bean. Bean modules must have their referenced bean initialized somehow. So it's rather common to have the module content initialized through a startup action depending on the session state or dynamically constructed by a standard action like {@code AddBeanAsSubModuleAction}. This type of module is definitely the one that offers maximum flexibility to handle arbitrary models.

<table>
<caption>MobileBeanModule properties</caption>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Property</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p><strong>projectedViewDescriptor</strong></p>
<p><code></code></p></td>
<td align="left"><p>Mobile bean module only support page views as projected views descriptors. {@inheritDoc}</p></td>
</tr>
</tbody>
</table>


